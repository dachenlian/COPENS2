.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "CWB::CEQL 3pm"
.TH CWB::CEQL 3pm "2018-11-30" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CWB::CEQL \- The Common Elementary Query Language for CQP front\-ends
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # end users: see section "CEQL SYNTAX" below for an overview of CEQL notation
\&
\&  use CWB::CEQL;
\&  our $CEQL = new CWB::CEQL;
\&
\&  # configuration settings (see METHODS section for details and default values)
\&  $CEQL\->SetParam("pos_attribute", "tags");         # p\-attribute for POS tags
\&  $CEQL\->SetParam("lemma_attribute", "hw");         # p\-attribute for lemmas
\&  $CEQL\->SetParam("simple_pos", \e%lookup_table);    # lookup table for simple POS
\&  $self\->NewParam("simple_pos_attribute", "class"); # p\-attribute for simple POS
\&  $self\->NewParam("s_attributes", {"s" => 1});      # s\-attributes allowed in CEQL queries
\&  $self\->NewParam("default_ignore_case", 1);        # if 1, default to case\-folded search
\&  $self\->NewParam("default_ignore_diac", 0);        # if 1, default to accent\-folded search
\&
\&  $cqp_query = $CEQL\->Parse($ceql_query);
\&  if (not defined $cqp_query) {
\&    @error_msg = $CEQL\->ErrorMessage;
\&    $html_msg = $CEQL\->HtmlErrorMessage;
\&  }
\&  # $cqp_query can now be sent to CQP backend (e.g. with CWB::CQP module)
\&
\&  #### extend or modify standard CEQL grammar by subclassing ####
\&  package BNCWEB::CEQL;
\&  use base \*(AqCWB::CEQL\*(Aq;
\&
\&  sub lemma {
\&    ## overwrite \*(Aqlemma\*(Aq rule here (e.g. to allow for BNCweb\*(Aqs \`\`{bucket/N}\*(Aq\*(Aq notation)
\&    my $orig_result = $self\->SUPER::lemma($string); # call original rule if needed
\&  }
\&
\&  ## you can now use BNCWEB::CEQL in the same way as CWB::CEQL
.Ve
.SH ""
.IX Header ""
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the core syntax of the \fBCommon Elementary Query Language\fR (\fB\s-1CEQL\s0\fR) as a \fB\s-1DPP\s0\fR grammar (see CWB::CEQL::Parser for details).
It can either be used directly, adjusting configuration settings with the \fBSetParam\fR method as required, or subclass \fB\s-1CWB::CEQL\s0\fR in order to modify and/or extend the grammar.  In the latter case, you are strongly advised not to change the meaning of core \s-1CEQL\s0 features, so that end-users can rely on the same familiar syntax in all CEQL-based Web interfaces.
.PP
A complete specification of the core \s-1CEQL\s0 syntax can be found in section \*(L"\s-1CEQL SYNTAX\*(R"\s0 below.  This is the most important part of the documentation for end users and can also be found online at <http://cwb.sf.net/ceql.php>.
.PP
Application developers can find an overview of relevant \s-1API\s0 methods and the available configuration parameters (\s-1CWB\s0 attributes for different linguistic annotations, default case/accent\-folding, etc.) in section \*(L"\s-1METHODS\*(R"\s0.
.PP
Section \*(L"\s-1EXTENDING CEQL\*(R"\s0 explains how to extend or customise \s-1CEQL\s0 syntax by subclassing \fB\s-1CWB::CEQL\s0\fR.  It is highly recommended to read the technical documentation in section \*(L"\s-1STANDARD CEQL RULES\*(R"\s0 and the source code of the \fB\s-1CWB::CEQL\s0\fR module.  Extended rules are most conveniently implemented as modified copies of the methods defined there.
.SH "METHODS"
.IX Header "METHODS"
The following \s-1API\s0 methods are inherited from \fBCWB::CEQL::Parser\fR.  The explanations below focus on their application in a \s-1CEQL\s0 simple query frontend.  The documentation of \fBSetParam\fR includes a complete listing of available configuration parameters as well as their usage and default values.
.IP "\fI\f(CI$CEQL\fI\fR = \fBnew\fR \s-1CWB::CEQL\s0;" 4
.IX Item "$CEQL = new CWB::CEQL;"
Create parser object for \s-1CEQL\s0 queries.  Use the \fBParse\fR method of \fI\f(CI$CEQL\fI\fR
to translate a \s-1CEQL\s0 query into \s-1CQP\s0 code.
.IP "\fI\f(CI$cqp_query\fI\fR = \fI\f(CI$CEQL\fI\fR\->\fBParse\fR(\fI\f(CI$simple_query\fI\fR);" 4
.IX Item "$cqp_query = $CEQL->Parse($simple_query);"
Parses simple query in \s-1CEQL\s0 syntax and returns equivalent \s-1CQP\s0 code.  If there
is a syntax error in \fI\f(CI$simple_query\fI\fR or parsing fails for some other reason,
an \fBundef\fRined value is returned.
.ie n .IP "@text_lines = \fI\f(CI$CEQL\fI\fR\->\fBErrorMessage\fR;" 4
.el .IP "\f(CW@text_lines\fR = \fI\f(CI$CEQL\fI\fR\->\fBErrorMessage\fR;" 4
.IX Item "@text_lines = $CEQL->ErrorMessage;"
.PD 0
.ie n .IP "$html_code = \fI\f(CI$CEQL\fI\fR\->\fBHtmlErrorMessage\fR;" 4
.el .IP "\f(CW$html_code\fR = \fI\f(CI$CEQL\fI\fR\->\fBHtmlErrorMessage\fR;" 4
.IX Item "$html_code = $CEQL->HtmlErrorMessage;"
.PD
If the last \s-1CEQL\s0 query failed to parse, these methods return an error message
either as a list of text lines (\fBErrorMessage\fR) or as pre-formatted \s-1HTML\s0 code
that can be used directly by a Web interface (\fBHtmlErrorMessage\fR).  The error
message includes a backtrace of the internal call stack in order to help users
identify the precise location of the problem.
.IP "\fI\f(CI$CEQL\fI\fR\->\fBSetParam\fR(\fI\f(CI$name\fI\fR, \fI\f(CI$value\fI\fR);" 4
.IX Item "$CEQL->SetParam($name, $value);"
Change parameters of the \s-1CEQL\s0 grammar.  Currently, the following parameters
are available:
.RS 4
.ie n .IP """pos_attribute""" 4
.el .IP "\f(CWpos_attribute\fR" 4
.IX Item "pos_attribute"
The p\-attribute used to store part-of-speech tags in the \s-1CWB\s0 corpus (default:
\&\f(CW\*(C`pos\*(C'\fR).  \s-1CEQL\s0 queries should not be used for corpora without \s-1POS\s0 tagging,
which we consider to be a minimal level of annotation.
.ie n .IP """lemma_attribute""" 4
.el .IP "\f(CWlemma_attribute\fR" 4
.IX Item "lemma_attribute"
The p\-attribute used to store lemmata (base forms) in the \s-1CWB\s0 corpus (default:
\&\f(CW\*(C`lemma\*(C'\fR).  Set to \fBundef\fR if the corpus has not been lemmatised.
.ie n .IP """simple_pos""" 4
.el .IP "\f(CWsimple_pos\fR" 4
.IX Item "simple_pos"
Lookup table for simple part-of-speech tags (in \s-1CEQL\s0 constructions like
\&\f(CW\*(C`run_{N}\*(C'\fR).  Must be a hashref with simple \s-1POS\s0 tags as keys and \s-1CQP\s0 regular
expressions matching an appropriate set of standard \s-1POS\s0 tags as the
corresponding values.  The default value is \fBundef\fR, indicating that no
simple \s-1POS\s0 tags have been defined.  A very basic setup for the Penn
Treebank tag set might look like this:
.Sp
.Vb 5
\&  $CEQL\->SetParam("simple_pos", {
\&      "N" => "NN.*",   # common nouns
\&      "V" => "V.*",    # any verb forms
\&      "A" => "JJ.*",   # adjectives
\&    });
.Ve
.ie n .IP """simple_pos_attribute""" 4
.el .IP "\f(CWsimple_pos_attribute\fR" 4
.IX Item "simple_pos_attribute"
Simple \s-1POS\s0 tags may use a different p\-attribute than standard \s-1POS\s0 tags,
specified by the \f(CW\*(C`simple_pos_attribute\*(C'\fR parameter.  If it is set to \fBundef\fR
(default), the \f(CW\*(C`pos_attribute\*(C'\fR will be used for simplified \s-1POS\s0 tags as well.
.ie n .IP """s_attributes""" 4
.el .IP "\f(CWs_attributes\fR" 4
.IX Item "s_attributes"
Lookup table indicating which s\-attributes in the \s-1CWB\s0 corpus may be accessed
in \s-1CEQL\s0 queries (using the \s-1XML\s0 tag notation, e.g. \f(CW\*(C`<s>\*(C'\fR or \f(CW\*(C`</s>\*(C'\fR,
or as a distance operator in proximity queries, e.g. \f(CW\*(C`<<s>>\*(C'\fR).  The
main purpose of this table is to keep the \s-1CEQL\s0 parser from passing through
arbitrary tags to the \s-1CQP\s0 code, which might generate confusing error messages.
Must be a hashref with the names of valid s\-attributes as keys mapped to \s-1TRUE\s0
values.  The default setting only allows sentences or s\-unit, which should be
annotated in every corpus:
.Sp
.Vb 1
\&  $CEQL\->SetParam("s_attributes", { "s" => 1 });
.Ve
.ie n .IP """default_ignore_case""" 4
.el .IP "\f(CWdefault_ignore_case\fR" 4
.IX Item "default_ignore_case"
Indicates whether \s-1CEQL\s0 queries should perform case-insensitive matching for
word forms and lemmas (\f(CW\*(C`:c\*(C'\fR modifier), which can be overridden with an
explicit \f(CW\*(C`:C\*(C'\fR modifier.  By default, case-insensitive matching is activated,
i.e. \f(CW\*(C`default_ignore_case\*(C'\fR is set to 1.
.ie n .IP """default_ignore_diac""" 4
.el .IP "\f(CWdefault_ignore_diac\fR" 4
.IX Item "default_ignore_diac"
Indicates whether \s-1CEQL\s0 queries should ignore accents (\fIdiacritics\fR) for word
forms and lemmas (\f(CW\*(C`:d\*(C'\fR modifier), which can be overridden with an explicit
\&\f(CW\*(C`:D\*(C'\fR modifier.  By default, matching does \fInot\fR ignore accents,
i.e. \f(CW\*(C`default_ignore_diac\*(C'\fR is set to 0.
.RE
.RS 4
.RE
.PP
See the CWB::CEQL::Parser manpage for more detailed information and further methods.
.SH "CEQL SYNTAX"
.IX Header "CEQL SYNTAX"
\&\fB** \s-1TODO\s0 **\fR
.SH "EXTENDING CEQL"
.IX Header "EXTENDING CEQL"
\&\fB** \s-1TODO\s0 **\fR: How to extend the standard \s-1CEQL\s0 grammar by subclassing. Note that the grammar is split into many small rules, so 
it is easy to modify by overriding individual rules completely (without having to call the original rule in between or having to
replicate complicated functionality).
.PP
See CWB::CEQL::Parser for details on how to write grammar rules. You should always have a copy of the \fB\s-1CWB::CEQL\s0\fR source code 
file at hand when writing your extensions. All rules of the standard \s-1CEQL\s0 grammar are listed below with short descriptions of their function and purpose.
.SH "STANDARD CEQL RULES"
.IX Header "STANDARD CEQL RULES"
.ie n .IP """ceql_query""" 4
.el .IP "\f(CWceql_query\fR" 4
.IX Item "ceql_query"
.PD 0
.ie n .IP """default""" 4
.el .IP "\f(CWdefault\fR" 4
.IX Item "default"
.PD
The default rule of \fB\s-1CWB::CEQL\s0\fR is \f(CW\*(C`ceql_query\*(C'\fR.  After sanitising
whitespace, it uses a heuristic to determine whether the input string is a
\&\fBphrase query\fR or a \fBproximity query\fR and delegates parsing to the
appropriate rule (\f(CW\*(C`phrase_query\*(C'\fR or \f(CW\*(C`proximity_query\*(C'\fR).
.SS "Phrase Query"
.IX Subsection "Phrase Query"
.ie n .IP """phrase_query""" 4
.el .IP "\f(CWphrase_query\fR" 4
.IX Item "phrase_query"
A phrase query is the standard form of \s-1CEQL\s0 syntax.  It matches a single token
described by constraints on word form, lemma and/or part-of-speech tag, a
sequence of such tokens, or a complex lexico-grammatical pattern.  The
\&\f(CW\*(C`phrase_query\*(C'\fR rule splits its input into whitespace-separated token
expressions, \s-1XML\s0 tags and metacharacters such as \f(CW\*(C`(\*(C'\fR, \f(CW\*(C`)\*(C'\fR and \f(CW\*(C`|\*(C'\fR.  Then it
applies the \f(CW\*(C`phrase_element\*(C'\fR rule to each item in turn, and concatenates the
results into the complete \s-1CQP\s0 query.  The phrase query may start with an embedded
modifier such as \f(CW\*(C`(?longest)\*(C'\fR to change the matching strategy.
.ie n .IP """phrase_element""" 4
.el .IP "\f(CWphrase_element\fR" 4
.IX Item "phrase_element"
A phrase element is either a token expression (delegated to rule
\&\f(CW\*(C`token_expression\*(C'\fR), a \s-1XML\s0 tag for matching structure boundaries (delegated
to rule \f(CW\*(C`xml_tag\*(C'\fR), sequences of arbitrary (\f(CW\*(C`+\*(C'\fR) or skipped (\f(CW\*(C`*\*(C'\fR) tokens,
or a phrase-level metacharacter (the latter two are handled by the
\&\f(CW\*(C`phrase_element\*(C'\fR rule itself).  Proper nesting of parenthesised groups is
automatically ensured by the parser.
.ie n .IP """xml_tag""" 4
.el .IP "\f(CWxml_tag\fR" 4
.IX Item "xml_tag"
A start or end tag matching the boundary of an s\-attribute region. The
\&\f(CW\*(C`xml_tag\*(C'\fR rule performs validation, in particularly ensuring that the
region name is listed as an allowed s\-attribute in the parameter
\&\f(CW\*(C`s_attributes\*(C'\fR, then passes the tag through to the \s-1CQP\s0 query.
.Sp
For a start tag, an optional wildcard pattern constraint may be specified
in the form \f(CW\*(C`<\f(CItag\f(CW=\f(CIpattern\f(CW>\*(C'\fR. The parser does not check whether
the selected s\-attribute in fact has annotations. Note that case\- and
diacritic-insensitive matching is not supported (not even as a default option).
.SS "Proximity Query"
.IX Subsection "Proximity Query"
.ie n .IP """proximity_query""" 4
.el .IP "\f(CWproximity_query\fR" 4
.IX Item "proximity_query"
A proximity query searches for combinations of words within a certain distance
of each other, specified either as a number of tokens (\fInumeric distance\fR) or
as co-occurrence within an s\-attribute region (\fIstructural distance\fR).  The
\&\f(CW\*(C`proximity_query\*(C'\fR rule splits its input into a sequence of token patterns,
distance operators and parentheses used for grouping.  Shorthand notation for
word sequences is expanded (e.g. \f(CW\*(C`as long as\*(C'\fR into \f(CW\*(C`as >>1>> long >>2>>
as\*(C'\fR), and then the \f(CW\*(C`proximity_expression\*(C'\fR rule is applied to each item in
turn.  A shift-reduce algorithm in \f(CW\*(C`proximity_expression\*(C'\fR reduces the
resulting list into a single \s-1CQP\s0 query (using the undocumented \*(L"\s-1MU\*(R"\s0 notation).
.ie n .IP """proximity_expression""" 4
.el .IP "\f(CWproximity_expression\fR" 4
.IX Item "proximity_expression"
A proximity expression is either a token expression (delegated to
\&\f(CW\*(C`token_expression\*(C'\fR), a distance operator (delegated to \f(CW\*(C`distance_operator\*(C'\fR)
or a parenthesis for grouping subexpressions (handled directly).  At each
step, the current result list is examined to check whether the respective type
of proximity expression is valid here.  When 3 elements have been collected in
the result list (term, operator, term), they are reduced to a single term.
This ensures that the \fBApply\fR method in \f(CW\*(C`proximity_query\*(C'\fR returns only a
single string containing the (almost) complete \s-1CQP\s0 query.
.ie n .IP """distance_operator""" 4
.el .IP "\f(CWdistance_operator\fR" 4
.IX Item "distance_operator"
A distance operator specifies the allowed distance between two tokens or
subexpressions in a proximity query.  Numeric distances are given as a number
of tokens and can be two-sided (\f(CW\*(C`<<n>>\*(C'\fR) or one-sided (\f(CW\*(C`<<n<<\*(C'\fR
to find the second term to the left of the first, or \f(CW\*(C`>>n>>\*(C'\fR to find it
to the right).  Structural distances are always two-sided and specifies an
s\-attribute region, in which both items must co-occur (e.g. \f(CW\*(C`<<s>>\*(C'\fR).
.SS "Token Expression"
.IX Subsection "Token Expression"
.ie n .IP """token_expression""" 4
.el .IP "\f(CWtoken_expression\fR" 4
.IX Item "token_expression"
Evaluate complete token expression with word form (or lemma) constraint and or
part-of-speech (or simple \s-1POS\s0) constraint.  The two parts of the token
expression are passed on to \f(CW\*(C`word_or_lemma_constraint\*(C'\fR and \f(CW\*(C`pos_constraint\*(C'\fR,
respectively.  This rule returns a \s-1CQP\s0 token expression enclosed in square
brackets.
.SS "Word Form / Lemma"
.IX Subsection "Word Form / Lemma"
.ie n .IP """word_or_lemma_constraint""" 4
.el .IP "\f(CWword_or_lemma_constraint\fR" 4
.IX Item "word_or_lemma_constraint"
Evaluate complete word form or lemma constraint, including case/diacritics
flags, and return suitable \s-1CQP\s0 code to be included in a token expression
.ie n .IP """word_or_lemma""" 4
.el .IP "\f(CWword_or_lemma\fR" 4
.IX Item "word_or_lemma"
Evaluate word form (without curly braces) or lemma constraint (in curly braces,
or with alternative \f(CW\*(C`%\*(C'\fR marker appended) and return a single \s-1CQP\s0 constraint,
to which \f(CW%c\fR and \f(CW%d\fR flags can then be added.
.ie n .IP """wordform_pattern""" 4
.el .IP "\f(CWwordform_pattern\fR" 4
.IX Item "wordform_pattern"
Translate wildcard pattern for word form into \s-1CQP\s0 constraint (using the
default \f(CW\*(C`word\*(C'\fR attribute).
.ie n .IP """lemma_pattern""" 4
.el .IP "\f(CWlemma_pattern\fR" 4
.IX Item "lemma_pattern"
Translate wildcard pattern for lemma into \s-1CQP\s0 constraint, using the
appropriate p\-attribute for base forms (given by the parameter
\&\f(CW\*(C`lemma_attribute\*(C'\fR).
.SS "Parts of Speech"
.IX Subsection "Parts of Speech"
.ie n .IP """pos_constraint""" 4
.el .IP "\f(CWpos_constraint\fR" 4
.IX Item "pos_constraint"
Evaluate a part-of-speech constraint (either a \f(CW\*(C`pos_tag\*(C'\fR or \f(CW\*(C`simple_pos\*(C'\fR),
returning suitable \s-1CQP\s0 code to be included in a token expression.
.ie n .IP """pos_tag""" 4
.el .IP "\f(CWpos_tag\fR" 4
.IX Item "pos_tag"
Translate wildcard pattern for part-of-speech tag into \s-1CQP\s0 constraint, using
the appropriate p\-attribute for \s-1POS\s0 tags (given by the parameter
\&\f(CW\*(C`pos_attribute\*(C'\fR).
.ie n .IP """simple_pos""" 4
.el .IP "\f(CWsimple_pos\fR" 4
.IX Item "simple_pos"
Translate simple part-of-speech tag into \s-1CQP\s0 constraint.  The specified tag is
looked up in the hash provided by the \f(CW\*(C`simple_pos\*(C'\fR parameter, and replaced by
the regular expression listed there.  If the tag cannot be found, or if no simple
tags have been defined, a helpful error message is generated.
.SS "Wildcard Patterns"
.IX Subsection "Wildcard Patterns"
.ie n .IP """wildcard_pattern""" 4
.el .IP "\f(CWwildcard_pattern\fR" 4
.IX Item "wildcard_pattern"
Translate string containing wildcards into regular expression, which is
enclosed in double quotes so it can directly be interpolated into a \s-1CQP\s0 query.
.Sp
Internally, the input string is split into wildcards and literal substrings,
which are then processed one item at a time with the \f(CW\*(C`wildcard_item\*(C'\fR
rule.
.ie n .IP """wildcard_item""" 4
.el .IP "\f(CWwildcard_item\fR" 4
.IX Item "wildcard_item"
Process an item of a wildcard pattern, which is either some metacharacter
(handled directly) or a literal substring (delegated to the \f(CW\*(C`literal_string\*(C'\fR
rule).  Proper nesting of alternatives is ensured using the shift-reduce
parsing mechanism (with \fBBeginGroup\fR and \fBEndGroup\fR calls).
.ie n .IP """literal_string""" 4
.el .IP "\f(CWliteral_string\fR" 4
.IX Item "literal_string"
Translate literal string into regular expression, escaping all metacharacters
with backslashes (backslashes in the input string are removed first).
.Sp
Note that escaping of \f(CW\*(C`^\*(C'\fR and \f(CW\*(C`"\*(C'\fR isn't fully reliable because \s-1CQP\s0 might
interpret the resulting escape sequences as latex-style accents if they are
followed by certain letters.  Future versions of \s-1CQP\s0 should provide a safer
escaping mechanism and/or allow interpretation of latex-style accents to be
turned off.
.SS "Internal Subroutines"
.IX Subsection "Internal Subroutines"
.IP "(\fI\f(CI$has_empty_alt\fI\fR, \fI\f(CI@tokens\fI\fR) = \fI\f(CI$self\fI\fR\->\fB_remove_empty_alternatives\fR(\fI\f(CI@tokens\fI\fR);" 4
.IX Item "($has_empty_alt, @tokens) = $self->_remove_empty_alternatives(@tokens);"
This internal method identifies and removes empty alternatives from a
tokenised group of alternatives (\fI\f(CI@tokens\fI\fR), with alternatives separated by
\&\f(CW\*(C`|\*(C'\fR tokens.  In particular, leading and trailing separator tokens are removed,
and multiple consecutive separators are collapsed to a single \f(CW\*(C`|\*(C'\fR.  The first
return value (\fI\f(CI$has_empty_alt\fI\fR) indicates whether one or more empty
alternatives were found; it is followed by the sanitised list of tokens.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2005\-2013 Stefan Evert [http::/purl.org/stefan.evert]
.PP
This software is provided \s-1AS IS\s0 and the author makes no warranty as to
its use and performance. You may use the software, redistribute and
modify it under the same terms as Perl itself.
